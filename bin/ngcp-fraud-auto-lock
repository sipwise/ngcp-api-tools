#!/usr/bin/perl

use strict;
use warnings;

use Email::Sender::Simple qw(sendmail);
use Sipwise::Provisioning::Billing;

my %LOCK = (
	none => undef,
	foreign => 1,
	outgoing => 2,
	incoming => 3,
	global => 4,
	0 => 'none',
	1 => 'foreign',
	2 => 'outgoing',
	3 => 'incoming',
	4 => 'global',
);

my $conf = Sipwise::Provisioning::Config->new()->get_config();

my $o = Sipwise::Provisioning::Billing->new();
my $db = $o->{database};

# We select only those billing profile hits which exceed the fraud limit and
# have an action attached to keep the number of result rows small.
# However, we select all account hits and manually check them later, as they
# can potentially override billing profile hits.
my $a = $db->sql_get_all_arrayref(<<"!");
SELECT bpinfo.type, bpinfo.id,
       IF (bpinfo.fraud_use_reseller_rates > 0, SUM(cdr.source_reseller_cost),
                                                SUM(cdr.source_customer_cost)) as interval_cost,
       bpinfo.fraud_interval_limit, bpinfo.fraud_interval_lock, bpinfo.fraud_interval_notify
FROM (
  SELECT contracts.id, bp.fraud_use_reseller_rates,
    CASE WHEN cfp.fraud_interval_limit > 0 THEN 'account_limit'
                                           ELSE 'profile_limit' END as type,
    IF (cfp.fraud_interval_limit > 0, cfp.fraud_interval_limit, bp.fraud_interval_limit) as fraud_interval_limit,
    IF (cfp.fraud_interval_limit > 0, cfp.fraud_interval_lock, bp.fraud_interval_lock) as fraud_interval_lock,
    IF (cfp.fraud_interval_limit > 0, cfp.fraud_interval_notify, bp.fraud_interval_notify) as fraud_interval_notify
  FROM billing.contracts
  JOIN billing.billing_profiles bp
    ON (bp.id =
      (SELECT m.billing_profile_id
        FROM billing.billing_mappings m
        JOIN products pr ON pr.id = m.product_id
        WHERE ((m.start_date IS NULL) OR (m.start_date <= NOW()))
          AND ((m.end_date IS NULL) OR (m.end_date >= NOW()))
          AND (m.contract_id = contracts.id)
          AND (pr.class IN ('sipaccount', 'pbxaccount') OR pr.class IS NULL)
        ORDER BY m.start_date DESC LIMIT 1
      )
    )
  LEFT JOIN billing.contract_fraud_preferences cfp ON cfp.contract_id = contracts.id
  WHERE (contracts.status = 'active')
    AND (cfp.fraud_interval_limit > 0 OR bp.fraud_interval_limit > 0)
) as bpinfo
JOIN accounting.cdr ON cdr.source_account_id = bpinfo.id
WHERE cdr.start_time BETWEEN UNIX_TIMESTAMP(DATE_FORMAT(NOW(), '%Y-%m-01 00:00:00'))
                         AND UNIX_TIMESTAMP(DATE_FORMAT(NOW() + INTERVAL 1 MONTH, '%Y-%m-01 00:00:00'))-1
GROUP BY bpinfo.id
HAVING interval_cost >= fraud_interval_limit
   AND (fraud_interval_lock > 0 OR fraud_interval_notify <> '')
!

my $x = {};
for my $e (@{ $a }) {
  if(exists $x->{$e->{id}}) {
    if($x->{$e->{id}}->{type} eq 'profile_limit' && $e->{type} eq 'account_limit') {

      # if account limit hits and it has lock and/or notify, mark for action
      if(defined $e->{fraud_interval_limit} and
         int($e->{interval_cost}) >= int($e->{fraud_interval_limit}) and
         ($e->{fraud_interval_lock} || $e->{fraud_interval_notify})) {

        $x->{$e->{id}} = $e;
      } else {
        # we have account fraud prefs set, but either the limit is not reached
        # or no actions are necessary, let it slip through, overriding
        # billing profile fraud settings
        delete $x->{$e->{id}};
      }
    }
  } else {
    # if account or billing profile limit hits and it has lock and/or notify,
    # mark for action
    if(defined $e->{fraud_interval_limit} and
       int($e->{interval_cost}) >= int($e->{fraud_interval_limit}) and
       ($e->{fraud_interval_lock} || $e->{fraud_interval_notify})) {

      $x->{$e->{id}} = $e;
    }
  }
}

for my $e (values %{ $x }) {

	$e->{fraud_interval_lock} and
		$o->lock_voip_account({id => $e->{id}, lock => $LOCK{$e->{fraud_interval_lock}}});

	$e->{fraud_interval_notify} or next;

	my $subs = $db->sql_get_all_arrayref(<<"!", $e->{id});
		SELECT s.username, d.domain, s.external_id
                  FROM voip_subscribers s
             LEFT JOIN domains d ON d.id = s.domain_id
                 WHERE s.contract_id = ?
                 AND s.status != 'terminated'
!

	my $cur = sprintf('%.2f', $e->{interval_cost} / 100);
	my $max = sprintf('%.2f', $e->{fraud_interval_limit} / 100);

    my ($subject, $body);
    if ($e->{fraud_interval_lock}) {
        $body = "Account ID " . $e->{id} . " has been locked due to exceeding the configured" . "\n"
              . "credit balance threshold ($cur >= $max ) in the "
              . ($e->{type} eq 'profile_limit' ? 'billing profile' : 'account settings') . "\n\n";
	$subject = 'Account ID ' . $e->{id} . ' locked by fraud detection';
    }
    else {
        $body = "Account ID " . $e->{id} . " is currently exceeding the configured credit balance" . "\n"
              . "threshold ($cur >= $max) in the "
              . ($e->{type} eq 'profile_limit' ? 'billing profile' : 'account settings') . ",\n"
              . "but has not been locked due to configuration.\n\n";
	$subject = 'Account ID ' . $e->{id} . ' exceeding fraud detection limit';
    }

	if (!$subs || !@$subs) {
		$body .= "There are no affected subscribers.\n";
	}
	else {
		$body .= "Affected subscribers:\n";
		for my $s (@$subs) {
			$body .= "\t$s->{username}\@$s->{domain}".
				($s->{external_id} ? " (external ID '$s->{external_id}')"
				: '') . "\n";
		}
	}

    sendmail ( Email::Simple->create(
        header => [
            To      => $e->{fraud_interval_notify},
            From    => $$conf{adminmail},
            Subject => $subject,
        ],
        body => $body,
    ));
}

1;
